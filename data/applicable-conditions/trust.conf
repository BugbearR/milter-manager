# -*- ruby -*-

trust = Object.new
trust.instance_eval do
  @envelope_from_domains = []
end

class << trust
  def add_envelope_from_domain(domain_matcher=Proc.new)
    @envelope_from_domains << domain_matcher
  end

  def trusted_envelope_from_domain?(envelope_from)
    user, domain = parse_envelope_from(envelope_from)
    return false if domain.nil?
    match?(@envelope_from_domains, normalize_domain(domain))
  end

  private
  def normalize_domain(domain)
    domain.downcase
  end

  def match?(list, host)
    list.any? do |matcher|
      if matcher.respond_to?(:call)
        matcher.call(host)
      else
        matcher === host
      end
    end
  end

  def parse_envelope_from(envelope_from)
    user = domain = nil
    if /\A<(.+?)@(.+?)>\z/ =~ envelope_from
      user = $1
      domain = $2
    end
    [user, domain]
  end
end

singleton_class = class << self; self; end
singleton_class.send(:define_method, :trust) do
  trust
end

trust.add_envelope_from_domain("gmail.com")
trust.add_envelope_from_domain("hotmail.com")
trust.add_envelope_from_domain("msn.com")
trust.add_envelope_from_domain("yahoo.co.jp")
trust.add_envelope_from_domain("softbank.ne.jp")
trust.add_envelope_from_domain("clear-code.com")

define_applicable_condition("Trust") do |condition|
  condition.description = "Set {trusted_*}=yes macros for trusted session"

  condition.define_envelope_from_stopper do |context, from|
    if trust.trusted_envelope_from_domain?(from)
      context["trusted_domain"] = "yes"
    end
    false
  end
end
