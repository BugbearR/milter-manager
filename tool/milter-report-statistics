#!/usr/bin/env ruby
#
# Copyright (C) 2011  Kouhei Sutou <kou@clear-code.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

require 'pathname'
require 'time'
require 'scanf'
require 'optparse'

class MilterStatus
  def initialize(proc_path)
    @proc_path = proc_path
    @status = parse_status(read_proc_path("status"))
  end

  def target?(targets)
    _name = name
    return false if _name.empty?
    no_lt_name = _name.sub(/\Alt-/, '')
    targets.any? {|target| _name == target or no_lt_name == target}
  end

  def name
    @name ||= File.basename(command_line[0] || '')
  end

  def pid
    @status["Pid"]
  end

  def vss
    @status["VmSize"]
  end

  def rss
    @status["VmRSS"]
  end

  def cpu_time
    ps["time"]
  end

  def cpu_percent
    ps["pcpu"]
  end

  def n_file_descriptors
    @n_file_descriptors ||= (@proc_path + "fd").entries.size
  end

  def command_line
    @command_line ||= read_proc_path("cmdline").split(/\0/)
  end

  private
  def read_proc_path(type)
    begin
      (@proc_path + type).read
    rescue SystemCallError
      ""
    end
  end

  def parse_status(status_text)
    status = {}
    status_text.each_line do |line|
      key, value = line.chomp.split(/\s*:\s*/, 2)
      status[key] = value
    end
    status
  end

  def ps
    @ps ||= retrieve_ps_info
  end

  def retrieve_ps_info
    ps_info = {}
    items = ["time", "pcpu"]
    ps_result = `ps -p #{pid} --no-headers -o #{items.join(",")}`
    values = ps_result.split(/\s+/)
    items.each_with_index do |item, i|
      ps_info[item] = values[i]
    end
    ps_info
  end
end

class MilterStatisticsReporter
  def initialize(targets)
    @targets = targets
  end

  def show_header
    show("Time", "PID", "VSS", "RSS", "%CPU", "CPU time", "#FD", "command")
  end

  def report
    reported = false
    Pathname.glob("/proc/[0-9]*") do |proc_path|
      status = MilterStatus.new(proc_path)
      next unless status.target?(@targets)
      reported = true
      show(Time.now.strftime("%H:%M:%S"),
           status.pid,
           status.vss,
           status.rss,
           status.cpu_percent,
           status.cpu_time,
           status.n_file_descriptors,
           status.command_line.join(" "))
    end
    unless reported
      puts "not-found"
      exit(false)
    end
  end

  private
  def show(time, pid, vss, rss, cpu_percent, cpu_time, n_fds, command_line)
    items = [time, pid, vss, rss, cpu_percent, cpu_time, n_fds, command_line]
    puts("%8s %6s %9s %9s %5s %8s %5s %s" % items)
  end
end

if __FILE__ == $0
  options = OptionParser.new do |_options|
    _options.banner += " TARGET1 TARGET2 ..."
  end
  targets = options.parse!(ARGV)
  if targets.empty?
    puts options
    exit(false)
  end

  reporter = MilterStatisticsReporter.new(ARGV)
  reporter.show_header
  loop do
    begin
      reporter.report
      sleep(1)
    rescue Interrupt
      break
    end
  end
end

# vi:ts=2:nowrap:ai:expandtab:sw=2
