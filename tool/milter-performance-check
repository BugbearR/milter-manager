#!/usr/bin/env ruby
#
# Copyright (C) 2008-2009  Kouhei Sutou <kou@cozmixng.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

require 'pathname'
require 'time'
require 'find'
require 'optparse'
require 'net/smtp'
require 'digest/sha2'

class MilterPerformanceTool
  def initialize
    @smtp_server = "localhost"
    @smtp_port = 25
    @helo_fqdn = "localhost.localdomain"
    @from = "from@example.com"
    @recipients = []
    @force_from = nil
    @force_recipients = nil
    @default_recipients = ["to@example.com"]
    @n_mails = 100
    @mails = []
    @period = nil
    @mail_source_from_stdin = nil
  end

  def parse_options(argv)
    opts = OptionParser.new do |opts|
      opts.separator ""
      opts.separator "Help options:"

      opts.on("-h", "--help", "Show this message") do
        puts opts
        exit(0)
      end

      opts.separator ""
      opts.separator "Application options:"

      opts.on("--smtp-server=SERVER",
              "Use SERVER as SMTP server",
              "(#{@smtp_server})") do |smtp_server|
        @smtp_server = smtp_server
      end

      opts.on("--smtp-port=PORT", Integer,
              "Use PORT as SMTP port",
              "(#{@smtp_port})") do |smtp_port|
        @smtp_port = smtp_port
      end

      opts.on("--helo-fqdn=FQDN",
              "Use FQDN for SMTP HELO command as default value.",
              "(#{@helo_fqdn})") do |helo_fqdn|
        @helo_fqdn = helo_fqdn
      end

      opts.on("--from=FROM",
              "Use FROM as envelope from address",
              "on SMTP MAIL command as default value.",
              "(#{@from})") do |from|
        @from = from
      end

      opts.on("--recipient=RECIPIENT",
              "Use RECIPIENT as envelope recipient address",
              "on SMTP RCPT command as default value.",
              "This option can be used n-times to set multi recipients.",
              "(#{@default_recipients.inspect})") do |recipient|
        @recipients << recipient
      end

      opts.on("--force-from=FROM",
              "Ensure using FROM as envelope from address on SMTP MAIL command.",
              "(#{@force_from})") do |from|
        @force_from = from
      end

      opts.on("--recipient=RECIPIENT",
              "Use RECIPIENT as envelope recipient address",
              "on SMTP RCPT command as default value.",
              "This option can be used n-times to set multi recipients.",
              "(#{@default_recipients.inspect})") do |recipient|
        @recipients << recipient
      end

      opts.on("--force-recipient=RECIPIENT",
              "Ensure using RECIPIENT as envelope recipient address",
              "on SMTP RCPT command as default value.",
              "This option can be used n-times to set multi recipients.",
              "(#{@force_recipients.inspect})") do |recipient|
        @force_recipients ||= []
        @force_recipients << recipient
      end

      opts.on("--n-mails=N", Integer,
              "Send a test mail N times",
              "This option is ignored when mail files are specified",
              "(#{@n_mails})") do |n_mails|
        @n_mails = n_mails
      end

      opts.on("--period=PERIOD",
              "Send mail files on average in PERIOD seconds/minutes/hours",
              "e.g.: 5s, 5m, 1.5h and so on. Default is seconds",
              "(#{@period})") do |period|
        @period = parse_period(period)
      end
    end
    @mails = opts.parse!(argv)
    @recipients = @default_recipients if @recipients.empty?
  end

  def run
    Thread.abort_on_exception = true
    @elapsed_time = 0
    mails = expand_mails(@mails)
    mails = [mails[0]] * @n_mails if mails.size <= 1
    if @period
      threads = send_mails_in_period(mails)
    else
      threads = send_mails_in_parallel(mails)
    end
    threads.each do |thread|
      thread.join
    end
  end

  def report
    puts "Processed #{@n_mails} in #{@elapsed_time} sec."
    puts "Average #{@n_mails / @elapsed_time} mails/sec." if @elapsed_time > 0
  end

  private
  def expand_mails(mails)
    expanded_mails = []
    mails.each do |mail|
      Find.find(mail) do |file|
        expanded_mails << file if File.file?(file)
      end
    end
    expanded_mails.sort
  end

  def send_mails_in_period(mails)
    interval =  mails.size / @period
    mails.collect do |mail|
      thread = Thread.start do
        @elapsed_time += send_mail(mail)
      end
      sleep(interval) if interval > 0
      thread
    end
  end

  def send_mails_in_parallel(mails)
    mails.collect do |mail|
      Thread.start do
        @elapsed_time += send_mail(mail)
      end
    end
  end

  def send_mail(mail_source_file=nil)
    if mail_source_file
      if mail_source_file == "-" and File.exist?(mail_source_file)
        mail_source = read_mails_source_from_stdin
      else
        mail_source = File.read(mail_source_file)
      end
    else
      mail_source = generate_mail_source
    end
    helo_fqdn, from, recipients = parse_mail_source(mail_source)
    helo_fqdn ||= @helo_fqdn
    from ||= @from
    recipients ||= @recipients

    from = @force_from || from
    recipients = @force_recipients || recipients

    start_time = Time.now
    begin
      Net::SMTP.start(@smtp_server, @port, helo_fqdn) do |smtp|
        smtp.send_mail(mail_source, from, *recipients)
      end
    rescue Net::ProtoFatalError
      puts "SMTP error: #{$!}"
    end
    Time.now - start_time
  end

  def read_mails_source_from_stdin
    if @mail_source_from_stdin
      @mail_source_from_stdin.gsub(/^Message-Id:.*$/) do
        "Message-Id: <#{random_tag}@mail.example.com>"
      end
    else
      @mail_source_from_stdin = ARGF.read
    end
  end

  def parse_mail_source(source)
    header_part, body_part = source.split(/(?:\r?\n){2}/, 2)
    _, *names_and_values = header_part.split(/^([a-z][a-z\-]+):\s*/i)
    headers = {}
    received = []
    until names_and_values.empty?
      name = names_and_values.shift
      value = names_and_values.shift
      value = value.chomp.gsub(/(?:\r?\n)\s*/, ' ')
      received << value if name == "Received"
      headers[name] = value
    end
    helo_fqdn = extract_helo_fqdn_from_received(received[0])
    from = headers["From"]
    recipients = parse_recipient_header(headers["To"])
    recipients += parse_recipient_header(headers["Cc"])
    recipients = nil if recipients.empty?
    [helo_fqdn, from, recipients]
  end

  def parse_recipient_header(header_value)
    return [] if header_value.nil?
    header_value.split(/\s*,\s*/)
  end

  def extract_helo_fqdn_from_received(received)
    return nil if received.nil?
    if /\Afrom ([a-z.]+)/i =~ received
      $1
    else
      nil
    end
  end

  def parse_period(period)
    if /\A(\d+(:.\d+)?)(s|sec|seconds?|m|min|minutes?|h|hours?)?\z/i =~ period
      numeric = $1
      unit = $2
      numeric = Float(numeric)
      unit ||= "seconds"
      case unit.downcase[0]
      when ?s
        numeric
      when ?m
        numeric * 60
      when ?h
        numeric * 60 * 60
      else
        raise OptionParser::InvalidArgument, "invalid period unit"
      end
    else
      raise OptionParser::InvalidArgument, "invalid period format"
    end
  end

  def generate_mail_source
    now = Time.now.rfc2822
    <<-EOM
Return-Path: <#{@from}>
Received: from #{@helo_fqdn} (#{@helo_fqdn} [192.168.1.1])
	by mail.example.com with ESMTP id #{generate_id};
	#{now}
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Content-Type: text/plain; charset=US-ASCII
X-Mailer: milter-performance-check
Message-Id: <#{random_tag}@mail.example.com>
Subject: test mail
From: #{@from}
To: #{@recipients.join(', ')}
Date: #{now}

Hello,

This is a test mail.
EOM
  end

  def generate_id
    characters = ("0".."9").to_a + ("a".."z").to_a + ("A".."Z").to_a
    length = 10
    id = ""
    length.times do
      id << characters[rand(characters.size)]
    end
    id
  end

  def random_tag
    Digest::SHA2.hexdigest("#{Time.now.to_i.to_s}.#{rand(Time.now.to_i)}")
  end
end

if __FILE__ == $0
  performance_tool = MilterPerformanceTool.new
  performance_tool.parse_options(ARGV)
  performance_tool.run
  performance_tool.report
end

# vi:ts=2:nowrap:ai:expandtab:sw=2
