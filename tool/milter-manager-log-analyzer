#!/usr/bin/env ruby
#
# Copyright (C) 2008-2009  Kouhei Sutou <kou@cozmixng.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

require 'English'
require 'pathname'
require 'fileutils'
require 'time'
require 'optparse'
require 'erb'

require 'RRD'

module RRD
  module_function
  def last_update_time(file)
    time = last(file)
    if time and time < Time.at(0)
      time = Time.at(Integer(`rrdtool last '#{file}'`))
    end
    time
  end
end

class MilterManagerLogAnalyzer
  module LogData
    class Session
      attr_accessor :name, :start_time, :end_time
      def initialize(name)
        @name = name
        @start_time = nil
        @end_time = nil
      end
    end

    class Mail
      attr_accessor :status, :time, :key
      def initialize(status, time)
        @key = status
        @status = status
        @time = time
      end
    end

    class Stop
      attr_accessor :state, :name, :time
      def initialize(state, name, time)
        @state = state
        @name = name
        @time = time
      end

      def key
        @state
      end
    end
  end

  module GraphData
    class TimeRange
      def initialize(rrd_step, rows)
        @rrd_step = rrd_step
        @rows = rows
      end
    end

    class DayRange < TimeRange
      def name
        "Day"
      end

      def steps
        (3600 * 24) / (@rrd_step * @rows) + 1
      end
    end

    class WeekRange < TimeRange
      def name
        "Week"
      end

      def steps
        DayRange.new(@rrd_step, @rows).steps * 7
      end
    end

    class MonthRange < TimeRange
      def name
        "Month"
      end

      def steps
        WeekRange.new(@rrd_step, @rows).steps * 5
      end
    end

    class YearRange < TimeRange
      def name
        "Year"
      end

      def steps
        MonthRange.new(@rrd_step, @rows).steps * 12
      end
    end

    class TimeSpan
      attr_accessor :name
      def initialize(name)
        @name = name
      end

      def step
        case @name
        when "second"
          1
        when "minute"
          60
        when "hour"
          3600
        end
      end

      def short_name
        case @name
        when "second"
          "sec"
        when "minute"
          "min"
        when "hour"
          "hour"
        end
      end

      def rows
        case @name
        when "second"
          86400 # 1day
        when "minute"
          43200 # 4weeks
        when "hour"
          8760 # 365days
        end
      end

      def default_start_time
        case @name
        when "second"
          "-3h" # 1hour
        when "minute"
          "-24h" # 12hours
        when "hour"
          "-7d" # 1day
        end
      end

      def adjust_time(time)
        case @name
        when "second"
          time
        when "minute"
          Time.utc(0, time.min, time.hour, time.mday, time.mon, time.year, time.wday, time.yday, time.isdst, time.zone)
        when "hour"
          Time.utc(0, 0, time.hour, time.mday, time.mon, time.year, time.wday, time.yday, time.isdst, time.zone)
        end
      end
    end

    class Count < Hash
      def [](key)
        super(key) ? super(key) : store(key, Hash.new(0))
      end
    end

    class Data
      def initialize(countings)
        @countings = countings
      end

      def empty?
        return true unless @countings
        @countings.each_value do |counting|
          return false unless counting.empty?
        end
        true
      end

      def last_time
        last_time = 0
        @countings.each_value do |counting|
          next if counting.empty?
          last_one = counting.sort { |a, b| a[0] <=> b[0] }.last[0]
          last_time = last_time > last_one ? last_time : last_one
        end
        last_time
      end

      def first_time
        first_time = 0
        @countings.each_value do |counting|
          next if counting.empty?
          first_one = counting.sort { |a, b| a[0] <=> b[0] }.first[0]
          if first_time.zero?
            first_time = first_one
          else
            first_time = first_time > first_one ? first_one : first_time
          end
        end
        first_time
      end

      def [](key)
        @countings[key]
      end

      def []=(key, value)
        @countings[key] = value
      end
    end
  end

  class GraphGenerator
    def initialize(output_directory, update_time)
      @output_directory = output_directory
      @update_time = update_time
      @data = []
      @items = nil
      @title = nil
      @vertical_label = nil
      @rrd_step = 60
      @width = 600
      @points_per_sample = 3
    end

    def rows
      @width / @points_per_sample
    end

    def count(time_span, last_update_time)
      counting = GraphData::Count.new()
      @data.each do |datum|
        time = time_span.adjust_time(datum.time)

        # ignore sessions which has been already registerd due to RRD.update fails on past time stamp
        if last_update_time
          next if time <= last_update_time
        end

        # ignore recent sessions due to RRD.update fails on past time stamp
        next if time >= time_span.adjust_time(@update_time)

        time = time.to_i
        key = datum.key

        count = counting[key][time]
        count = 0 if count == "U"
        count += 1
        counting[key][time] = count
      end
      counting
    end

    def collect_data(time_span, last_update_time)
      counting = count(time_span, last_update_time)
      GraphData::Data.new(counting)
    end

    def update_db(time_span)
      if File.exist?(rrd_file)
        last_update_time = RRD.last_update_time(rrd_file)
      else
        last_update_time = nil
      end

      data = collect_data(time_span, last_update_time)
      return if data.empty?

      end_time = data.last_time
      if last_update_time
        start_time = last_update_time + time_span.step
      else
        start_time = data.first_time
      end

      create_rrd(time_span, start_time, *@items) unless File.exist?(rrd_file)

      start_time.to_i.step(end_time, time_span.step) do |time|
        counts = []
        @items.each do |item|
          counts << data[item][time]
        end

        next if counts.uniq.length == 1 and counts.uniq.include?("U")

        # puts("update #{rrd_file} with #{Time.at(time).iso8601} #{counts.join(':')}")
        RRD.update(rrd_file,
                   "#{time}:#{counts.join(':')}")
      end
    end

    def update
      update_db(GraphData::TimeSpan.new("minute"))
    end

    def create_rrd(time_span, start_time, *args)
      step = @rrd_step

      day_range = GraphData::DayRange.new(@rrd_step, rows)
      week_range = GraphData::WeekRange.new(@rrd_step, rows)
      month_range = GraphData::MonthRange.new(@rrd_step, rows)
      year_range = GraphData::YearRange.new(@rrd_step, rows)
      RRD.create(rrd_file,
                 "--start", (start_time - 1).to_i.to_s,
                 "--step", step,
                 "RRA:MAX:0.5:#{day_range.steps}:#{rows}",
                 "RRA:MAX:0.5:#{week_range.steps}:#{rows}",
                 "RRA:MAX:0.5:#{month_range.steps}:#{rows}",
                 "RRA:MAX:0.5:#{year_range.steps}:#{rows}",
                 "RRA:AVERAGE:0.5:#{day_range.steps}:#{rows}",
                 "RRA:AVERAGE:0.5:#{week_range.steps}:#{rows}",
                 "RRA:AVERAGE:0.5:#{month_range.steps}:#{rows}",
                 "RRA:AVERAGE:0.5:#{year_range.steps}:#{rows}",
                 *args.map{|arg| "DS:#{arg}:GAUGE:#{step * 3}:0:U"})
    end

    def output_graph(time_span, range_class, options={}, *args)
      start_time = options[:start_time] || time_span.default_start_time
      end_time = options[:end_time] || guess_end_time(start_time)
      graph_tag = options[:graph_tag] || time_span.name
      width = options[:width] || @width
      height = options[:height] || 200

      return nil unless File.exist?(rrd_file)
      last_update_time = RRD.last_update_time(rrd_file)

      vertical_label = "#{@vertical_label}/#{time_span.short_name}"
      name = graph_name(graph_tag)

      range = range_class.new(@rrd_step, rows)
      items = @items.inject([]) do |_items, item|
        _items + ["DEF:#{item}=#{rrd_file}:#{item}:AVERAGE",
                  "DEF:max_#{item}=#{rrd_file}:#{item}:MAX",
                  "CDEF:n_#{item}=#{item}",
                  "CDEF:real_#{item}=#{item}",
                  "CDEF:real_max_#{item}=max_#{item}",
                  "CDEF:real_n_#{item}=n_#{item},#{range.steps},*",
                  "CDEF:total_#{item}=PREV,UN,real_n_#{item},PREV,IF,real_n_#{item},+"]
      end

      data = items + args
      data << "COMMENT:[#{last_update_time.iso8601.gsub(/:/, '\:')}]\\r"
      RRD.graph(name,
                "--title", @title,
                "--vertical-label", vertical_label,
                "--start", start_time.to_s,
                "--end", end_time.to_s,
                "--width", width.to_s,
                "--height", height.to_s,
                "--alt-y-grid",
                *data)
      name
    end

    private
    def build_path(*paths)
      File.join(*([@output_directory, *paths].compact))
    end

    def guess_end_time(start_time)
      if start_time.is_a?(String)
        "now"
      else
        end_time = Time.now.to_i
        step = start_time.abs * @points_per_sample / @width
        end_time - (end_time % step)
      end
    end
  end

  class SessionGraphGenerator < GraphGenerator
    def initialize(output_directory, update_time)
      super(output_directory, update_time)
      @title = 'Sessions'
      @vertical_label = "sessions"
      @items = ["smtp", "child"]
      @child_sessions = []
      @client_sessions = []
    end

    def rrd_file
      build_path("milter-log.session.rrd")
    end

    def graph_name(tag)
      build_path("session.#{tag}.png")
    end

    def collect_session(time_stamp, content, sessions, regex)
      if regex.match(content)
        elapsed = $1
        name = $2
        session = LogData::Session.new(name)
        session.end_time = time_stamp
        session.start_time = time_stamp - Float(elapsed)
        sessions << session
      end
      sessions
    end

    def feed(time_stamp, content)
      @child_sessions =
        collect_session(time_stamp, content, @child_sessions,
                        /\A\[milter\]\[end\]\[(.+)\]\(.+\): (.+)\z/)
      @client_sessions =
        collect_session(time_stamp, content, @client_sessions,
                        /\A\[session\]\[end\]\[(.+)\]\(.+\)\z/)
    end

    def count_sessions(sessions, time_span, last_update_time)
      counting = Hash.new(0)
      sessions.each do |session|
        next if session.end_time == nil
        start_time = time_span.adjust_time(session.start_time)
        end_time = time_span.adjust_time(session.end_time)

        # ignore sessions which has been already registerd due to RRD.update fails on past time stamp
        if last_update_time
          next if end_time <= last_update_time
          next if start_time <= last_update_time
        end

        # ignore recent sessions due to RRD.update fails on past time stamp
        next if end_time >= time_span.adjust_time(@update_time)
        next if start_time >= time_span.adjust_time(@update_time)

        start_time = start_time.to_i
        end_time = end_time.to_i

        start_time.step(end_time, time_span.step) do |time|
          time = end_time # FIXME
          count = counting[time]
          count = 0 if count == "U"
          count += 1
          counting[time] = count
          break
        end
      end
      counting
    end

    def collect_data(time_span, last_update_time)
      counting = GraphData::Count.new()
      counting["smtp"] = count_sessions(@client_sessions, time_span, last_update_time)
      counting["child"] = count_sessions(@child_sessions, time_span, last_update_time)
      GraphData::Data.new(counting)
    end

    def output_graph(time_span, range_class, options={})
      super(time_span, range_class, options,
            "AREA:n_smtp#0000ff:SMTP  ",
            "GPRINT:total_smtp:MAX:total\\: %8.0lf sessions",
            "GPRINT:smtp:AVERAGE:avg\\: %6.2lf sessions/min",
            "GPRINT:max_smtp:MAX:max\\: %4.0lf sessions/min\\l",
            "LINE2:n_child#00ff00:milter",
            "GPRINT:total_child:MAX:total\\: %8.0lf sessions",
            "GPRINT:child:AVERAGE:avg\\: %6.2lf sessions/min",
            "GPRINT:max_child:MAX:max\\: %4.0lf sessions/min\\l")
    end
  end

  class MailStatusGraphGenerator < GraphGenerator
    def initialize(output_directory, update_time)
      super(output_directory, update_time)
      @vertical_label = "mails"
      @title = 'Processed mails'
      @items = ["pass", "accept",
                "reject", "discard",
                "temporary-failure",
                "quarantine"]
    end

    def rrd_file
      build_path("milter-log.mail.rrd")
    end

    def graph_name(tag)
      build_path("mail.#{tag}.png")
    end

    def feed(time_stamp, content)
      if /\A\[reply\]\[(.+)\]\[(.+)\]\z/ =~ content
        state = $1
        status = $2
        return if status == "continue" and state != "end-of-message"
        status = "pass" if status == "continue"
        @data << LogData::Mail.new(status, time_stamp)
      end
    end

    def output_graph(time_span, range_class, options={})
      entries = [
                 ["AREA", "pass", "#0000ff", "Pass"],
                 ["STACK", "accept", "#00ff00", "Accept"],
                 ["STACK", "reject", "#ff0000", "Reject"],
                 ["STACK", "discard", "#ffd400", "Discard"],
                 ["STACK", "temporary-failure", "#888888", "Temp-Fail"],
                 ["STACK", "quarantine", "#a52a2a", "Quarantine"],
                ]
      max_label_size = entries.collect {|_, _, _, label| label.size}.max

      items = []
      entries.each do |type, name, color, label|
        items << "#{type}:#{name}#{color}:#{label.ljust(max_label_size)}"
        items << "GPRINT:total_#{name}:MAX:total\\: %11.0lf mails"
        items << "GPRINT:#{name}:AVERAGE:avg\\: %9.2lf mails/min"
        items << "GPRINT:max_#{name}:MAX:max\\: %7.0lf mails/min\\l"
      end

      range = range_class.new(@rrd_step, rows)
      path = build_path("milter-log.session.rrd")
      items << "DEF:smtp=#{path}:smtp:AVERAGE"
      items << "DEF:max_smtp=#{path}:smtp:MAX"
      items << "CDEF:n_smtp=smtp"
      items << "CDEF:real_n_smtp=n_smtp,#{range.steps},*"
      items << "CDEF:total_smtp=PREV,UN,real_n_smtp,PREV,IF,real_n_smtp,+"

      label = "SMTP".ljust(max_label_size)
      items << "LINE2:n_smtp#000000:#{label}"
      items << "GPRINT:total_smtp:MAX:total\\: %8.0lf sessions"
      items << "GPRINT:smtp:AVERAGE:avg\\: %6.2lf sessions/min"
      items << "GPRINT:max_smtp:MAX:max\\: %4.0lf sessions/min\\l"
      super(time_span, range_class, options, *items)
    end
  end

  class StopGraphGenerator < GraphGenerator
    def initialize(output_directory, update_time)
      super(output_directory, update_time)
      @title = 'Stopped milters'
      @vertical_label = "milters"
      @items = ["connect",
                "helo",
                "envelope-from",
                "envelope-recipient",
                "header",
                "body",
                "end-of-message"]
    end

    def rrd_file
      build_path("milter-log.stop.rrd")
    end

    def graph_name(tag)
      build_path("stop.#{tag}.png")
    end

    def feed(time_stamp, content)
      if /\A\[stop\]\[(.+)\]: (.+)\z/ =~ content
        state = $1
        name = $2
        @data << LogData::Stop.new(state, name, time_stamp)
      end
    end

    def collect_data(time_span, last_update_time)
      stop_counting = count(time_span, last_update_time)
      GraphData::Data.new(stop_counting)
    end

    def output_graph(time_span, range_class, options={})
      entries = [
                 ["AREA", "connect", "#0000ff"],
                 ["STACK", "helo", "#ff00ff"],
                 ["STACK", "envelope-from", "#00ffff"],
                 ["STACK", "envelope-recipient", "#ffff00"],
                 ["STACK", "header", "#a52a2a"],
                 ["STACK", "body", "#ff0000"],
                 ["STACK", "end-of-message", "#00ff00"],
                ]
      max_name_size = entries.collect {|_, name, _| name.size}.max

      items = []
      entries.each do |type, name, color|
        items << "#{type}:#{name}#{color}:#{name.ljust(max_name_size)}"
        items << "GPRINT:total_#{name}:MAX:total\\: %8.0lf milters"
        items << "GPRINT:#{name}:AVERAGE:avg\\: %6.2lf milters/min"
        items << "GPRINT:max_#{name}:MAX:max\\: %4.0lf milters/min\\l"
      end

      range = range_class.new(@rrd_step, rows)
      path = build_path("milter-log.session.rrd")
      items << "DEF:child=#{path}:child:AVERAGE"
      items << "DEF:max_child=#{path}:child:MAX"
      items << "CDEF:n_milters=child,UN,0,child,IF"
      items << "CDEF:real_n_milters=n_milters,#{range.steps},*"
      items << "CDEF:total_milters=PREV,UN,real_n_milters,PREV,IF,real_n_milters,+"

      label = 'total'.ljust(max_name_size)
      items << "LINE2:n_milters#000000:#{label}"
      items << "GPRINT:total_milters:MAX:total\\: %8.0lf milters"
      items << "GPRINT:child:AVERAGE:avg\\: %6.2lf milters/min"
      items << "GPRINT:max_child:MAX:max\\: %4.0lf milters/min\\l"
      super(time_span, range_class, options, *items)
    end
  end

  class HTMLGenerator
    include ERB::Util

    def initialize(graph_info)
      @graph_info = graph_info
    end

    def generate
      header + index + graphs + footer
    end

    private
    def header
      <<-EOH
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta http-equiv="Refresh" content="300" />
    <meta http-equiv="Pragma" content="no-cache" />
    <title>milter-manager statistics</title>
  </head>

  <body>
    <h1>milter-manager statistics</h1>
EOH
    end

    def index
      result = "<ul>\n"
      @graph_info.each do |time_span, graphs|
        next if graphs.empty?
        result << %Q[  <li><a href="\##{h(time_span)}">#{h(time_span)}</a></li>\n]
      end
      result << "</ul>\n"
      result
    end

    def graphs
      result = ""
      @graph_info.each do |time_span, graphs|
        next if graphs.empty?
        result << %Q[<h2 id=\"#{h(time_span)}\">#{h(time_span)}</h2>\n]
        graphs.each do |graph|
          result << %Q[  <p><img src="#{h(File.basename(graph))}" /></p>\n]
        end
        result << "\n"
      end
      result
    end

    def footer
      <<-EOF
  </body>
</html>
EOF
    end
  end

  def initialize
    @log = ARGF
    @update_db = true
    @sessions = nil
    @mail_status = nil
    @stops = nil
    @output_directory = "."
    @output_graphs = []
  end

  def parse_options(argv)
    opts = OptionParser.new do |opts|
      opts.on("--log=LOG_FILE",
              "The log file name in which is stored Milter log",
              "(STDIN)") do |log|
        @log = File.open(log)
      end

      opts.on("--output-directory=DIRECTORY",
              "Output graph, HTML and graph data to DIRECTORY",
              "(#{@output_directory})") do |directory|
        @output_directory = directory
        unless File.exist?(@output_directory)
          FileUtils.mkdir_p(@output_directory)
        end
      end

      opts.on("--[no-]update-db",
              "Update RRD database with log file",
              "(#{@update_db})") do |boolean|
        @update_db = boolean
      end
    end
    opts.parse!(argv)
  end

  def update
    return unless @update_db

    listeners = [sessions, mail_status, stops]
    @log.each_line do |line|
      case line
      when /\A(\w{3} +\d+ \d+:\d+:\d+) [\w\-]+ ([\w\-]+)\[\d+\]: /
        time_stamp = $1
        name = $2
        content = $POSTMATCH
        next unless name == "milter-manager"
        if /\A\[statistics\] / =~ content
          content = $POSTMATCH.chomp
        else
          next
        end
        time_stamp = Time.parse(time_stamp).utc
        listeners.each do |listener|
          listener.feed(time_stamp, content)
        end
      else
      end
    end

    listeners.each do |listener|
      listener.update
    end
  end

  def output_graph(time_span, range, label, options={})
    output_graphs = []
    [sessions, mail_status, stops].each do |generator|
      file_name = generator.output_graph(GraphData::TimeSpan.new(time_span),
                                         range, options)
      output_graphs << file_name if file_name
    end
    @output_graphs << [label || time_span, output_graphs]
  end

  def output_all_graph
    output_graph("minute", GraphData::DayRange, "Last Day",
                 :start_time => -3600 * 24,
                 :graph_tag => "day")
    output_graph("minute", GraphData::WeekRange, "Last Week",
                 :start_time => -3600 * 24 * 7,
                 :graph_tag => "week")
    output_graph("minute", GraphData::MonthRange, "Last Month",
                 :start_time => -3600 * 24 * 31,
                 :graph_tag => "month")
    output_graph("minute", GraphData::YearRange, "Last Year",
                 :start_time => -3600 * 24 * 365,
                 :graph_tag => "year")
  end

  def output_html
    File.open(File.join(@output_directory, "index.html"), "w") do |html|
      generator = HTMLGenerator.new(@output_graphs)
      html.print(generator.generate)
    end
  end

  private
  def now
    @now ||= Time.now.utc
  end

  def sessions
    @sessions ||= SessionGraphGenerator.new(@output_directory, now)
  end

  def mail_status
    @mail_status ||= MailStatusGraphGenerator.new(@output_directory, now)
  end

  def stops
    @stops ||= StopGraphGenerator.new(@output_directory, now)
  end
end

milter_log_tool = MilterManagerLogAnalyzer.new
milter_log_tool.parse_options(ARGV)
milter_log_tool.update
milter_log_tool.output_all_graph
milter_log_tool.output_html

# vi:ts=2:nowrap:ai:expandtab:sw=2
